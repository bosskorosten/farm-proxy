"use strict";var __getOwnPropNames=Object.getOwnPropertyNames;var __commonJS=(cb,mod)=>function(){return mod||(0,cb[__getOwnPropNames(cb)[0]])((mod={exports:{}}).exports,mod),mod.exports};var require_src=__commonJS({"../../../../.yarn/cache/real-require-npm-0.2.0-7f69dbc7b6-ddf44ee763.zip/node_modules/real-require/src/index.js"(exports2,module2){var realImport2=new Function("modulePath","return import(modulePath)");function realRequire2(modulePath){return typeof __non_webpack__require__=="function"?__non_webpack__require__(modulePath):require(modulePath)}module2.exports={realImport:realImport2,realRequire:realRequire2}}});var require_indexes=__commonJS({"../../../../.yarn/cache/thread-stream-npm-2.7.0-b184293d78-03e743a2cc.zip/node_modules/thread-stream/lib/indexes.js"(exports2,module2){"use strict";module2.exports={WRITE_INDEX:4,READ_INDEX:8}}});var require_wait=__commonJS({"../../../../.yarn/cache/thread-stream-npm-2.7.0-b184293d78-03e743a2cc.zip/node_modules/thread-stream/lib/wait.js"(exports2,module2){"use strict";function wait(state2,index,expected,timeout,done){let max=Date.now()+timeout,current=Atomics.load(state2,index);if(current===expected){done(null,"ok");return}let prior=current,check=backoff=>{Date.now()>max?done(null,"timed-out"):setTimeout(()=>{prior=current,current=Atomics.load(state2,index),current===prior?check(backoff>=1e3?1e3:backoff*2):current===expected?done(null,"ok"):done(null,"not-equal")},backoff)};check(1)}function waitDiff2(state2,index,expected,timeout,done){let max=Date.now()+timeout,current=Atomics.load(state2,index);if(current!==expected){done(null,"ok");return}let check=backoff=>{Date.now()>max?done(null,"timed-out"):setTimeout(()=>{current=Atomics.load(state2,index),current!==expected?done(null,"ok"):check(backoff>=1e3?1e3:backoff*2)},backoff)};check(1)}module2.exports={wait,waitDiff:waitDiff2}}});var{realImport,realRequire}=require_src(),{workerData,parentPort}=require("worker_threads"),{WRITE_INDEX,READ_INDEX}=require_indexes(),{waitDiff}=require_wait(),{dataBuf,filename,stateBuf}=workerData,destination,state=new Int32Array(stateBuf),data=Buffer.from(dataBuf);async function start(){let worker;try{filename.endsWith(".ts")||filename.endsWith(".cts")?(process[Symbol.for("ts-node.register.instance")]?process.env.TS_NODE_DEV&&realRequire("ts-node-dev"):realRequire("ts-node/register"),worker=realRequire(decodeURIComponent(filename.replace(process.platform==="win32"?"file:///":"file://","")))):worker=await realImport(filename)}catch(error){if((error.code==="ENOTDIR"||error.code==="ERR_MODULE_NOT_FOUND")&&filename.startsWith("file://"))worker=realRequire(decodeURIComponent(filename.replace("file://","")));else if(error.code===void 0||error.code==="ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING")worker=realRequire(decodeURIComponent(filename.replace(process.platform==="win32"?"file:///":"file://","")));else throw error}typeof worker=="object"&&(worker=worker.default),typeof worker=="object"&&(worker=worker.default),destination=await worker(workerData.workerData),destination.on("error",function(err){Atomics.store(state,WRITE_INDEX,-2),Atomics.notify(state,WRITE_INDEX),Atomics.store(state,READ_INDEX,-2),Atomics.notify(state,READ_INDEX),parentPort.postMessage({code:"ERROR",err})}),destination.on("close",function(){let end=Atomics.load(state,WRITE_INDEX);Atomics.store(state,READ_INDEX,end),Atomics.notify(state,READ_INDEX),setImmediate(()=>{process.exit(0)})})}start().then(function(){parentPort.postMessage({code:"READY"}),process.nextTick(run)});function run(){let current=Atomics.load(state,READ_INDEX),end=Atomics.load(state,WRITE_INDEX);if(end===current){end===data.length?waitDiff(state,READ_INDEX,end,1/0,run):waitDiff(state,WRITE_INDEX,end,1/0,run);return}if(end===-1){destination.end();return}let toWrite=data.toString("utf8",current,end);destination.write(toWrite)?(Atomics.store(state,READ_INDEX,end),Atomics.notify(state,READ_INDEX),setImmediate(run)):destination.once("drain",function(){Atomics.store(state,READ_INDEX,end),Atomics.notify(state,READ_INDEX),run()})}process.on("unhandledRejection",function(err){parentPort.postMessage({code:"ERROR",err}),process.exit(1)});process.on("uncaughtException",function(err){parentPort.postMessage({code:"ERROR",err}),process.exit(1)});process.once("exit",exitCode=>{if(exitCode!==0){process.exit(exitCode);return}destination?.writableNeedDrain&&!destination?.writableEnded&&parentPort.postMessage({code:"WARNING",err:new Error("ThreadStream: process exited before destination stream was drained. this may indicate that the destination stream try to write to a another missing stream")}),process.exit(0)});
//# sourceMappingURL=thread-stream-worker.cjs.map
